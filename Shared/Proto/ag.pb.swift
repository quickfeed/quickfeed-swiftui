// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ag.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct User {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var isAdmin: Bool = false

  var name: String = String()

  var studentID: String = String()

  var email: String = String()

  var avatarURL: String = String()

  var login: String = String()

  var remoteIdentities: [RemoteIdentity] = []

  var enrollments: [Enrollment] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Users {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var users: [User] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RemoteIdentity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var provider: String = String()

  var remoteID: UInt64 = 0

  var accessToken: String = String()

  var userID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Group {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var name: String = String()

  var courseID: UInt64 = 0

  var teamID: UInt64 = 0

  var status: Group.GroupStatus = .pending

  var users: [User] = []

  var enrollments: [Enrollment] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum GroupStatus: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case pending // = 0
    case approved // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .pending
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .pending
      case 1: self = .approved
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .pending: return 0
      case .approved: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Group.GroupStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Group.GroupStatus] = [
    .pending,
    .approved,
  ]
}

#endif  // swift(>=4.2)

struct Groups {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var groups: [Group] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Course {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var courseCreatorID: UInt64 = 0

  var name: String = String()

  var code: String = String()

  var year: UInt32 = 0

  var tag: String = String()

  var provider: String = String()

  var organizationID: UInt64 = 0

  /// The organization's SCM name, e.g. uis-dat520-2020.
  var organizationPath: String = String()

  var slipDays: UInt32 = 0

  var enrolled: Enrollment.UserStatus = .none

  var enrollments: [Enrollment] = []

  var assignments: [Assignment] = []

  var groups: [Group] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Courses {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var courses: [Course] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Repository {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var organizationID: UInt64 = 0

  /// ID of a github repository
  var repositoryID: UInt64 = 0

  var userID: UInt64 = 0

  var groupID: UInt64 = 0

  var htmlurl: String = String()

  var repoType: Repository.TypeEnum = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case none // = 0
    case courseinfo // = 1
    case assignments // = 2
    case tests // = 3
    case user // = 4
    case group // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .none
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .courseinfo
      case 2: self = .assignments
      case 3: self = .tests
      case 4: self = .user
      case 5: self = .group
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .none: return 0
      case .courseinfo: return 1
      case .assignments: return 2
      case .tests: return 3
      case .user: return 4
      case .group: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Repository.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Repository.TypeEnum] = [
    .none,
    .courseinfo,
    .assignments,
    .tests,
    .user,
    .group,
  ]
}

#endif  // swift(>=4.2)

struct Enrollment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var courseID: UInt64 {
    get {return _storage._courseID}
    set {_uniqueStorage()._courseID = newValue}
  }

  var userID: UInt64 {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  var groupID: UInt64 {
    get {return _storage._groupID}
    set {_uniqueStorage()._groupID = newValue}
  }

  var hasTeacherScopes_p: Bool {
    get {return _storage._hasTeacherScopes_p}
    set {_uniqueStorage()._hasTeacherScopes_p = newValue}
  }

  var user: User {
    get {return _storage._user ?? User()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {_uniqueStorage()._user = nil}

  var course: Course {
    get {return _storage._course ?? Course()}
    set {_uniqueStorage()._course = newValue}
  }
  /// Returns true if `course` has been explicitly set.
  var hasCourse: Bool {return _storage._course != nil}
  /// Clears the value of `course`. Subsequent reads from it will return its default value.
  mutating func clearCourse() {_uniqueStorage()._course = nil}

  var group: Group {
    get {return _storage._group ?? Group()}
    set {_uniqueStorage()._group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  var hasGroup: Bool {return _storage._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  mutating func clearGroup() {_uniqueStorage()._group = nil}

  var status: Enrollment.UserStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  var state: Enrollment.DisplayState {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  var slipDaysRemaining: UInt32 {
    get {return _storage._slipDaysRemaining}
    set {_uniqueStorage()._slipDaysRemaining = newValue}
  }

  var lastActivityDate: String {
    get {return _storage._lastActivityDate}
    set {_uniqueStorage()._lastActivityDate = newValue}
  }

  var totalApproved: UInt64 {
    get {return _storage._totalApproved}
    set {_uniqueStorage()._totalApproved = newValue}
  }

  var usedSlipDays: [UsedSlipDays] {
    get {return _storage._usedSlipDays}
    set {_uniqueStorage()._usedSlipDays = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum UserStatus: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case none // = 0
    case pending // = 1
    case student // = 2
    case teacher // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .none
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .pending
      case 2: self = .student
      case 3: self = .teacher
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .none: return 0
      case .pending: return 1
      case .student: return 2
      case .teacher: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  enum DisplayState: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unset // = 0
    case hidden // = 1
    case visible // = 2
    case favorite // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unset
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unset
      case 1: self = .hidden
      case 2: self = .visible
      case 3: self = .favorite
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unset: return 0
      case .hidden: return 1
      case .visible: return 2
      case .favorite: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Enrollment.UserStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Enrollment.UserStatus] = [
    .none,
    .pending,
    .student,
    .teacher,
  ]
}

extension Enrollment.DisplayState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Enrollment.DisplayState] = [
    .unset,
    .hidden,
    .visible,
    .favorite,
  ]
}

#endif  // swift(>=4.2)

struct UsedSlipDays {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var enrollmentID: UInt64 = 0

  var assignmentID: UInt64 = 0

  var usedSlipDays: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Enrollments {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enrollments: [Enrollment] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SubmissionLink {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var assignment: Assignment {
    get {return _storage._assignment ?? Assignment()}
    set {_uniqueStorage()._assignment = newValue}
  }
  /// Returns true if `assignment` has been explicitly set.
  var hasAssignment: Bool {return _storage._assignment != nil}
  /// Clears the value of `assignment`. Subsequent reads from it will return its default value.
  mutating func clearAssignment() {_uniqueStorage()._assignment = nil}

  var submission: Submission {
    get {return _storage._submission ?? Submission()}
    set {_uniqueStorage()._submission = newValue}
  }
  /// Returns true if `submission` has been explicitly set.
  var hasSubmission: Bool {return _storage._submission != nil}
  /// Clears the value of `submission`. Subsequent reads from it will return its default value.
  mutating func clearSubmission() {_uniqueStorage()._submission = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct EnrollmentLink {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// must have course and user/group preloaded
  var enrollment: Enrollment {
    get {return _enrollment ?? Enrollment()}
    set {_enrollment = newValue}
  }
  /// Returns true if `enrollment` has been explicitly set.
  var hasEnrollment: Bool {return self._enrollment != nil}
  /// Clears the value of `enrollment`. Subsequent reads from it will return its default value.
  mutating func clearEnrollment() {self._enrollment = nil}

  var submissions: [SubmissionLink] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _enrollment: Enrollment? = nil
}

struct CourseSubmissions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// preloaded assignments
  var course: Course {
    get {return _course ?? Course()}
    set {_course = newValue}
  }
  /// Returns true if `course` has been explicitly set.
  var hasCourse: Bool {return self._course != nil}
  /// Clears the value of `course`. Subsequent reads from it will return its default value.
  mutating func clearCourse() {self._course = nil}

  var links: [EnrollmentLink] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _course: Course? = nil
}

struct Assignment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var courseID: UInt64 = 0

  var name: String = String()

  var scriptFile: String = String()

  var deadline: String = String()

  var autoApprove: Bool = false

  var order: UInt32 = 0

  var isGroupLab: Bool = false

  /// defines minimal score limit for auto approval
  var scoreLimit: UInt32 = 0

  /// number of TA's to review submissions for this assignment 
  var reviewers: UInt32 = 0

  var skipTests: Bool = false

  var submissions: [Submission] = []

  var gradingBenchmarks: [GradingBenchmark] = []

  var containerTimeout: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Assignments {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var assignments: [Assignment] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Submission {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var assignmentID: UInt64 = 0

  var userID: UInt64 = 0

  var groupID: UInt64 = 0

  var score: UInt32 = 0

  var scoreObjects: String = String()

  var buildInfo: String = String()

  var commitHash: String = String()

  /// defines whether the feedback is visible for the student or group members
  var released: Bool = false

  var status: Submission.Status = .none

  var approvedDate: String = String()

  var reviews: [Review] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case none // = 0
    case approved // = 1
    case rejected // = 2
    case revision // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .none
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .approved
      case 2: self = .rejected
      case 3: self = .revision
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .none: return 0
      case .approved: return 1
      case .rejected: return 2
      case .revision: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Submission.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Submission.Status] = [
    .none,
    .approved,
    .rejected,
    .revision,
  ]
}

#endif  // swift(>=4.2)

struct Submissions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var submissions: [Submission] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GradingBenchmark {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var assignmentID: UInt64 = 0

  var heading: String = String()

  var comment: String = String()

  var criteria: [GradingCriterion] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Benchmarks {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var benchmarks: [GradingBenchmark] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GradingCriterion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var points: UInt64 = 0

  var benchmarkID: UInt64 = 0

  var description_p: String = String()

  var grade: GradingCriterion.Grade = .none

  var comment: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Grade: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case none // = 0
    case failed // = 1
    case passed // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .none
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .failed
      case 2: self = .passed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .none: return 0
      case .failed: return 1
      case .passed: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension GradingCriterion.Grade: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [GradingCriterion.Grade] = [
    .none,
    .failed,
    .passed,
  ]
}

#endif  // swift(>=4.2)

struct Review {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var submissionID: UInt64 = 0

  var reviewerID: UInt64 = 0

  /// JSON encoded grading criteria
  var review: String = String()

  var feedback: String = String()

  var ready: Bool = false

  var score: UInt64 = 0

  var benchmarks: [GradingBenchmark] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Reviewers {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var reviewers: [User] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ReviewRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var courseID: UInt64 = 0

  var review: Review {
    get {return _review ?? Review()}
    set {_review = newValue}
  }
  /// Returns true if `review` has been explicitly set.
  var hasReview: Bool {return self._review != nil}
  /// Clears the value of `review`. Subsequent reads from it will return its default value.
  mutating func clearReview() {self._review = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _review: Review? = nil
}

struct CourseRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var courseID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct UserRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GetGroupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var groupID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GroupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: UInt64 = 0

  var groupID: UInt64 = 0

  var courseID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Provider {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var provider: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct OrgRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var orgName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Organization {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 = 0

  var path: String = String()

  var avatar: String = String()

  var paymentPlan: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Organizations {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var organizations: [Organization] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EnrollmentRequest is a request for enrolled users of a given course,
/// whose enrollment status match those provided in the request. To ignore group members 
/// that otherwise match the enrollment request, set ignoreGroupMembers to true.
struct EnrollmentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var courseID: UInt64 = 0

  var ignoreGroupMembers: Bool = false

  var withActivity: Bool = false

  var statuses: [Enrollment.UserStatus] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EnrollmentStatusRequest is a request for a given user, with a specific enrollment status.
struct EnrollmentStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: UInt64 = 0

  var statuses: [Enrollment.UserStatus] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SubmissionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: UInt64 = 0

  var groupID: UInt64 = 0

  var courseID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct UpdateSubmissionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var submissionID: UInt64 = 0

  var courseID: UInt64 = 0

  var score: UInt32 = 0

  var released: Bool = false

  var status: Submission.Status = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct UpdateSubmissionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var courseID: UInt64 = 0

  var assignmentID: UInt64 = 0

  var scoreLimit: UInt32 = 0

  var release: Bool = false

  var approve: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SubmissionReviewersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var submissionID: UInt64 = 0

  var courseID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Providers {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var providers: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct URLRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var courseID: UInt64 = 0

  var repoTypes: [Repository.TypeEnum] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// used to check whether student/group submission repo is empty
struct RepositoryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: UInt64 = 0

  var groupID: UInt64 = 0

  var courseID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Repositories {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var urls: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct AuthorizationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var isAuthorized: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Status {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: UInt64 = 0

  var error: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SubmissionsForCourseRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var courseID: UInt64 = 0

  var type: SubmissionsForCourseRequest.TypeEnum = .all

  var skipBuildInfo: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case all // = 0
    case individual // = 1
    case group // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .all
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .all
      case 1: self = .individual
      case 2: self = .group
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .all: return 0
      case .individual: return 1
      case .group: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension SubmissionsForCourseRequest.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [SubmissionsForCourseRequest.TypeEnum] = [
    .all,
    .individual,
    .group,
  ]
}

#endif  // swift(>=4.2)

struct RebuildRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var submissionID: UInt64 = 0

  var assignmentID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CourseUserRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var courseCode: String = String()

  var courseYear: UInt32 = 0

  var userLogin: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct LoadCriteriaRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var courseID: UInt64 = 0

  var assignmentID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Void contains no fields. A server response with a Void still contains a gRPC status code,
/// which can be checked for success or failure. Status code 0 indicates that the requested action was successful,
/// whereas any other status code indicates some failure. As such, the status code can be used as a boolean result from the server.
struct Void {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "User"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
    2: .same(proto: "isAdmin"),
    3: .same(proto: "name"),
    4: .same(proto: "studentID"),
    5: .same(proto: "email"),
    6: .same(proto: "avatarURL"),
    7: .same(proto: "login"),
    8: .same(proto: "remoteIdentities"),
    9: .same(proto: "enrollments"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isAdmin) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.studentID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.login) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.remoteIdentities) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.enrollments) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.isAdmin != false {
      try visitor.visitSingularBoolField(value: self.isAdmin, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.studentID.isEmpty {
      try visitor.visitSingularStringField(value: self.studentID, fieldNumber: 4)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 5)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 6)
    }
    if !self.login.isEmpty {
      try visitor.visitSingularStringField(value: self.login, fieldNumber: 7)
    }
    if !self.remoteIdentities.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.remoteIdentities, fieldNumber: 8)
    }
    if !self.enrollments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.enrollments, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: User, rhs: User) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.isAdmin != rhs.isAdmin {return false}
    if lhs.name != rhs.name {return false}
    if lhs.studentID != rhs.studentID {return false}
    if lhs.email != rhs.email {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.login != rhs.login {return false}
    if lhs.remoteIdentities != rhs.remoteIdentities {return false}
    if lhs.enrollments != rhs.enrollments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Users: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Users"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "users"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.users) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.users.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.users, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Users, rhs: Users) -> Bool {
    if lhs.users != rhs.users {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RemoteIdentity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RemoteIdentity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
    2: .same(proto: "provider"),
    3: .same(proto: "remoteID"),
    4: .same(proto: "accessToken"),
    5: .same(proto: "userID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.provider) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.remoteID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.accessToken) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.provider.isEmpty {
      try visitor.visitSingularStringField(value: self.provider, fieldNumber: 2)
    }
    if self.remoteID != 0 {
      try visitor.visitSingularUInt64Field(value: self.remoteID, fieldNumber: 3)
    }
    if !self.accessToken.isEmpty {
      try visitor.visitSingularStringField(value: self.accessToken, fieldNumber: 4)
    }
    if self.userID != 0 {
      try visitor.visitSingularUInt64Field(value: self.userID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RemoteIdentity, rhs: RemoteIdentity) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.provider != rhs.provider {return false}
    if lhs.remoteID != rhs.remoteID {return false}
    if lhs.accessToken != rhs.accessToken {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Group: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Group"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
    2: .same(proto: "name"),
    3: .same(proto: "courseID"),
    4: .same(proto: "teamID"),
    5: .same(proto: "status"),
    6: .same(proto: "users"),
    7: .same(proto: "enrollments"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.courseID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.teamID) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.users) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.enrollments) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.courseID != 0 {
      try visitor.visitSingularUInt64Field(value: self.courseID, fieldNumber: 3)
    }
    if self.teamID != 0 {
      try visitor.visitSingularUInt64Field(value: self.teamID, fieldNumber: 4)
    }
    if self.status != .pending {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 5)
    }
    if !self.users.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.users, fieldNumber: 6)
    }
    if !self.enrollments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.enrollments, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Group, rhs: Group) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.courseID != rhs.courseID {return false}
    if lhs.teamID != rhs.teamID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.users != rhs.users {return false}
    if lhs.enrollments != rhs.enrollments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Group.GroupStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PENDING"),
    1: .same(proto: "APPROVED"),
  ]
}

extension Groups: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Groups"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groups"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.groups) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groups, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Groups, rhs: Groups) -> Bool {
    if lhs.groups != rhs.groups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Course: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Course"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
    2: .same(proto: "courseCreatorID"),
    3: .same(proto: "name"),
    4: .same(proto: "code"),
    5: .same(proto: "year"),
    6: .same(proto: "tag"),
    7: .same(proto: "provider"),
    8: .same(proto: "organizationID"),
    9: .same(proto: "organizationPath"),
    10: .same(proto: "slipDays"),
    11: .same(proto: "enrolled"),
    12: .same(proto: "enrollments"),
    13: .same(proto: "assignments"),
    14: .same(proto: "groups"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.courseCreatorID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.code) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.year) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.tag) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.provider) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.organizationID) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.organizationPath) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self.slipDays) }()
      case 11: try { try decoder.decodeSingularEnumField(value: &self.enrolled) }()
      case 12: try { try decoder.decodeRepeatedMessageField(value: &self.enrollments) }()
      case 13: try { try decoder.decodeRepeatedMessageField(value: &self.assignments) }()
      case 14: try { try decoder.decodeRepeatedMessageField(value: &self.groups) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.courseCreatorID != 0 {
      try visitor.visitSingularUInt64Field(value: self.courseCreatorID, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 4)
    }
    if self.year != 0 {
      try visitor.visitSingularUInt32Field(value: self.year, fieldNumber: 5)
    }
    if !self.tag.isEmpty {
      try visitor.visitSingularStringField(value: self.tag, fieldNumber: 6)
    }
    if !self.provider.isEmpty {
      try visitor.visitSingularStringField(value: self.provider, fieldNumber: 7)
    }
    if self.organizationID != 0 {
      try visitor.visitSingularUInt64Field(value: self.organizationID, fieldNumber: 8)
    }
    if !self.organizationPath.isEmpty {
      try visitor.visitSingularStringField(value: self.organizationPath, fieldNumber: 9)
    }
    if self.slipDays != 0 {
      try visitor.visitSingularUInt32Field(value: self.slipDays, fieldNumber: 10)
    }
    if self.enrolled != .none {
      try visitor.visitSingularEnumField(value: self.enrolled, fieldNumber: 11)
    }
    if !self.enrollments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.enrollments, fieldNumber: 12)
    }
    if !self.assignments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.assignments, fieldNumber: 13)
    }
    if !self.groups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groups, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Course, rhs: Course) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.courseCreatorID != rhs.courseCreatorID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.code != rhs.code {return false}
    if lhs.year != rhs.year {return false}
    if lhs.tag != rhs.tag {return false}
    if lhs.provider != rhs.provider {return false}
    if lhs.organizationID != rhs.organizationID {return false}
    if lhs.organizationPath != rhs.organizationPath {return false}
    if lhs.slipDays != rhs.slipDays {return false}
    if lhs.enrolled != rhs.enrolled {return false}
    if lhs.enrollments != rhs.enrollments {return false}
    if lhs.assignments != rhs.assignments {return false}
    if lhs.groups != rhs.groups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Courses: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Courses"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "courses"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.courses) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.courses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.courses, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Courses, rhs: Courses) -> Bool {
    if lhs.courses != rhs.courses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Repository: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Repository"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
    2: .same(proto: "organizationID"),
    3: .same(proto: "repositoryID"),
    4: .same(proto: "userID"),
    5: .same(proto: "groupID"),
    6: .same(proto: "HTMLURL"),
    7: .same(proto: "repoType"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.organizationID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.repositoryID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.userID) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.groupID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.htmlurl) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.repoType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.organizationID != 0 {
      try visitor.visitSingularUInt64Field(value: self.organizationID, fieldNumber: 2)
    }
    if self.repositoryID != 0 {
      try visitor.visitSingularUInt64Field(value: self.repositoryID, fieldNumber: 3)
    }
    if self.userID != 0 {
      try visitor.visitSingularUInt64Field(value: self.userID, fieldNumber: 4)
    }
    if self.groupID != 0 {
      try visitor.visitSingularUInt64Field(value: self.groupID, fieldNumber: 5)
    }
    if !self.htmlurl.isEmpty {
      try visitor.visitSingularStringField(value: self.htmlurl, fieldNumber: 6)
    }
    if self.repoType != .none {
      try visitor.visitSingularEnumField(value: self.repoType, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Repository, rhs: Repository) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.organizationID != rhs.organizationID {return false}
    if lhs.repositoryID != rhs.repositoryID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.htmlurl != rhs.htmlurl {return false}
    if lhs.repoType != rhs.repoType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Repository.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "COURSEINFO"),
    2: .same(proto: "ASSIGNMENTS"),
    3: .same(proto: "TESTS"),
    4: .same(proto: "USER"),
    5: .same(proto: "GROUP"),
  ]
}

extension Enrollment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Enrollment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
    2: .same(proto: "courseID"),
    3: .same(proto: "userID"),
    4: .same(proto: "groupID"),
    5: .same(proto: "hasTeacherScopes"),
    6: .same(proto: "user"),
    7: .same(proto: "course"),
    8: .same(proto: "group"),
    9: .same(proto: "status"),
    10: .same(proto: "state"),
    11: .same(proto: "slipDaysRemaining"),
    12: .same(proto: "lastActivityDate"),
    13: .same(proto: "totalApproved"),
    14: .same(proto: "usedSlipDays"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64 = 0
    var _courseID: UInt64 = 0
    var _userID: UInt64 = 0
    var _groupID: UInt64 = 0
    var _hasTeacherScopes_p: Bool = false
    var _user: User? = nil
    var _course: Course? = nil
    var _group: Group? = nil
    var _status: Enrollment.UserStatus = .none
    var _state: Enrollment.DisplayState = .unset
    var _slipDaysRemaining: UInt32 = 0
    var _lastActivityDate: String = String()
    var _totalApproved: UInt64 = 0
    var _usedSlipDays: [UsedSlipDays] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _courseID = source._courseID
      _userID = source._userID
      _groupID = source._groupID
      _hasTeacherScopes_p = source._hasTeacherScopes_p
      _user = source._user
      _course = source._course
      _group = source._group
      _status = source._status
      _state = source._state
      _slipDaysRemaining = source._slipDaysRemaining
      _lastActivityDate = source._lastActivityDate
      _totalApproved = source._totalApproved
      _usedSlipDays = source._usedSlipDays
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._courseID) }()
        case 3: try { try decoder.decodeSingularUInt64Field(value: &_storage._userID) }()
        case 4: try { try decoder.decodeSingularUInt64Field(value: &_storage._groupID) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._hasTeacherScopes_p) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._course) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._group) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._slipDaysRemaining) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._lastActivityDate) }()
        case 13: try { try decoder.decodeSingularUInt64Field(value: &_storage._totalApproved) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._usedSlipDays) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._id != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if _storage._courseID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._courseID, fieldNumber: 2)
      }
      if _storage._userID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._userID, fieldNumber: 3)
      }
      if _storage._groupID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._groupID, fieldNumber: 4)
      }
      if _storage._hasTeacherScopes_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasTeacherScopes_p, fieldNumber: 5)
      }
      if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._course {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._group {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if _storage._status != .none {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 9)
      }
      if _storage._state != .unset {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 10)
      }
      if _storage._slipDaysRemaining != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._slipDaysRemaining, fieldNumber: 11)
      }
      if !_storage._lastActivityDate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lastActivityDate, fieldNumber: 12)
      }
      if _storage._totalApproved != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._totalApproved, fieldNumber: 13)
      }
      if !_storage._usedSlipDays.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._usedSlipDays, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Enrollment, rhs: Enrollment) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._courseID != rhs_storage._courseID {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._groupID != rhs_storage._groupID {return false}
        if _storage._hasTeacherScopes_p != rhs_storage._hasTeacherScopes_p {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._course != rhs_storage._course {return false}
        if _storage._group != rhs_storage._group {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._slipDaysRemaining != rhs_storage._slipDaysRemaining {return false}
        if _storage._lastActivityDate != rhs_storage._lastActivityDate {return false}
        if _storage._totalApproved != rhs_storage._totalApproved {return false}
        if _storage._usedSlipDays != rhs_storage._usedSlipDays {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Enrollment.UserStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "PENDING"),
    2: .same(proto: "STUDENT"),
    3: .same(proto: "TEACHER"),
  ]
}

extension Enrollment.DisplayState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSET"),
    1: .same(proto: "HIDDEN"),
    2: .same(proto: "VISIBLE"),
    3: .same(proto: "FAVORITE"),
  ]
}

extension UsedSlipDays: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UsedSlipDays"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
    2: .same(proto: "enrollmentID"),
    3: .same(proto: "assignmentID"),
    4: .same(proto: "usedSlipDays"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.enrollmentID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.assignmentID) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.usedSlipDays) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.enrollmentID != 0 {
      try visitor.visitSingularUInt64Field(value: self.enrollmentID, fieldNumber: 2)
    }
    if self.assignmentID != 0 {
      try visitor.visitSingularUInt64Field(value: self.assignmentID, fieldNumber: 3)
    }
    if self.usedSlipDays != 0 {
      try visitor.visitSingularUInt32Field(value: self.usedSlipDays, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UsedSlipDays, rhs: UsedSlipDays) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.enrollmentID != rhs.enrollmentID {return false}
    if lhs.assignmentID != rhs.assignmentID {return false}
    if lhs.usedSlipDays != rhs.usedSlipDays {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Enrollments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Enrollments"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enrollments"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.enrollments) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.enrollments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.enrollments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Enrollments, rhs: Enrollments) -> Bool {
    if lhs.enrollments != rhs.enrollments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubmissionLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SubmissionLink"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "assignment"),
    2: .same(proto: "submission"),
  ]

  fileprivate class _StorageClass {
    var _assignment: Assignment? = nil
    var _submission: Submission? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _assignment = source._assignment
      _submission = source._submission
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._assignment) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._submission) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._assignment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._submission {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SubmissionLink, rhs: SubmissionLink) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._assignment != rhs_storage._assignment {return false}
        if _storage._submission != rhs_storage._submission {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EnrollmentLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "EnrollmentLink"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "enrollment"),
    3: .same(proto: "submissions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._enrollment) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.submissions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._enrollment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.submissions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.submissions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: EnrollmentLink, rhs: EnrollmentLink) -> Bool {
    if lhs._enrollment != rhs._enrollment {return false}
    if lhs.submissions != rhs.submissions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CourseSubmissions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CourseSubmissions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "course"),
    2: .same(proto: "links"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._course) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.links) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._course {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.links.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.links, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CourseSubmissions, rhs: CourseSubmissions) -> Bool {
    if lhs._course != rhs._course {return false}
    if lhs.links != rhs.links {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Assignment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Assignment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
    2: .same(proto: "courseID"),
    3: .same(proto: "name"),
    4: .same(proto: "scriptFile"),
    5: .same(proto: "deadline"),
    6: .same(proto: "autoApprove"),
    7: .same(proto: "order"),
    8: .same(proto: "isGroupLab"),
    9: .same(proto: "scoreLimit"),
    10: .same(proto: "reviewers"),
    11: .same(proto: "skipTests"),
    12: .same(proto: "submissions"),
    13: .same(proto: "gradingBenchmarks"),
    14: .same(proto: "containerTimeout"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.courseID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.scriptFile) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.deadline) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.autoApprove) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.order) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.isGroupLab) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.scoreLimit) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self.reviewers) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.skipTests) }()
      case 12: try { try decoder.decodeRepeatedMessageField(value: &self.submissions) }()
      case 13: try { try decoder.decodeRepeatedMessageField(value: &self.gradingBenchmarks) }()
      case 14: try { try decoder.decodeSingularUInt32Field(value: &self.containerTimeout) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.courseID != 0 {
      try visitor.visitSingularUInt64Field(value: self.courseID, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.scriptFile.isEmpty {
      try visitor.visitSingularStringField(value: self.scriptFile, fieldNumber: 4)
    }
    if !self.deadline.isEmpty {
      try visitor.visitSingularStringField(value: self.deadline, fieldNumber: 5)
    }
    if self.autoApprove != false {
      try visitor.visitSingularBoolField(value: self.autoApprove, fieldNumber: 6)
    }
    if self.order != 0 {
      try visitor.visitSingularUInt32Field(value: self.order, fieldNumber: 7)
    }
    if self.isGroupLab != false {
      try visitor.visitSingularBoolField(value: self.isGroupLab, fieldNumber: 8)
    }
    if self.scoreLimit != 0 {
      try visitor.visitSingularUInt32Field(value: self.scoreLimit, fieldNumber: 9)
    }
    if self.reviewers != 0 {
      try visitor.visitSingularUInt32Field(value: self.reviewers, fieldNumber: 10)
    }
    if self.skipTests != false {
      try visitor.visitSingularBoolField(value: self.skipTests, fieldNumber: 11)
    }
    if !self.submissions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.submissions, fieldNumber: 12)
    }
    if !self.gradingBenchmarks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.gradingBenchmarks, fieldNumber: 13)
    }
    if self.containerTimeout != 0 {
      try visitor.visitSingularUInt32Field(value: self.containerTimeout, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Assignment, rhs: Assignment) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.courseID != rhs.courseID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.scriptFile != rhs.scriptFile {return false}
    if lhs.deadline != rhs.deadline {return false}
    if lhs.autoApprove != rhs.autoApprove {return false}
    if lhs.order != rhs.order {return false}
    if lhs.isGroupLab != rhs.isGroupLab {return false}
    if lhs.scoreLimit != rhs.scoreLimit {return false}
    if lhs.reviewers != rhs.reviewers {return false}
    if lhs.skipTests != rhs.skipTests {return false}
    if lhs.submissions != rhs.submissions {return false}
    if lhs.gradingBenchmarks != rhs.gradingBenchmarks {return false}
    if lhs.containerTimeout != rhs.containerTimeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Assignments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Assignments"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "assignments"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.assignments) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.assignments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.assignments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Assignments, rhs: Assignments) -> Bool {
    if lhs.assignments != rhs.assignments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Submission: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Submission"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
    2: .same(proto: "assignmentID"),
    3: .same(proto: "userID"),
    4: .same(proto: "groupID"),
    5: .same(proto: "score"),
    6: .same(proto: "scoreObjects"),
    7: .same(proto: "buildInfo"),
    8: .same(proto: "commitHash"),
    9: .same(proto: "released"),
    10: .same(proto: "status"),
    11: .same(proto: "approvedDate"),
    12: .same(proto: "reviews"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.assignmentID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.groupID) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.score) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.scoreObjects) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.buildInfo) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.commitHash) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.released) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.approvedDate) }()
      case 12: try { try decoder.decodeRepeatedMessageField(value: &self.reviews) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.assignmentID != 0 {
      try visitor.visitSingularUInt64Field(value: self.assignmentID, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularUInt64Field(value: self.userID, fieldNumber: 3)
    }
    if self.groupID != 0 {
      try visitor.visitSingularUInt64Field(value: self.groupID, fieldNumber: 4)
    }
    if self.score != 0 {
      try visitor.visitSingularUInt32Field(value: self.score, fieldNumber: 5)
    }
    if !self.scoreObjects.isEmpty {
      try visitor.visitSingularStringField(value: self.scoreObjects, fieldNumber: 6)
    }
    if !self.buildInfo.isEmpty {
      try visitor.visitSingularStringField(value: self.buildInfo, fieldNumber: 7)
    }
    if !self.commitHash.isEmpty {
      try visitor.visitSingularStringField(value: self.commitHash, fieldNumber: 8)
    }
    if self.released != false {
      try visitor.visitSingularBoolField(value: self.released, fieldNumber: 9)
    }
    if self.status != .none {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 10)
    }
    if !self.approvedDate.isEmpty {
      try visitor.visitSingularStringField(value: self.approvedDate, fieldNumber: 11)
    }
    if !self.reviews.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reviews, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Submission, rhs: Submission) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.assignmentID != rhs.assignmentID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.score != rhs.score {return false}
    if lhs.scoreObjects != rhs.scoreObjects {return false}
    if lhs.buildInfo != rhs.buildInfo {return false}
    if lhs.commitHash != rhs.commitHash {return false}
    if lhs.released != rhs.released {return false}
    if lhs.status != rhs.status {return false}
    if lhs.approvedDate != rhs.approvedDate {return false}
    if lhs.reviews != rhs.reviews {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Submission.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "APPROVED"),
    2: .same(proto: "REJECTED"),
    3: .same(proto: "REVISION"),
  ]
}

extension Submissions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Submissions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "submissions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.submissions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.submissions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.submissions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Submissions, rhs: Submissions) -> Bool {
    if lhs.submissions != rhs.submissions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GradingBenchmark: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GradingBenchmark"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
    2: .same(proto: "assignmentID"),
    3: .same(proto: "heading"),
    4: .same(proto: "comment"),
    5: .same(proto: "criteria"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.assignmentID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.heading) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.comment) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.criteria) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.assignmentID != 0 {
      try visitor.visitSingularUInt64Field(value: self.assignmentID, fieldNumber: 2)
    }
    if !self.heading.isEmpty {
      try visitor.visitSingularStringField(value: self.heading, fieldNumber: 3)
    }
    if !self.comment.isEmpty {
      try visitor.visitSingularStringField(value: self.comment, fieldNumber: 4)
    }
    if !self.criteria.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.criteria, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GradingBenchmark, rhs: GradingBenchmark) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.assignmentID != rhs.assignmentID {return false}
    if lhs.heading != rhs.heading {return false}
    if lhs.comment != rhs.comment {return false}
    if lhs.criteria != rhs.criteria {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Benchmarks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Benchmarks"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "benchmarks"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.benchmarks) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.benchmarks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.benchmarks, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Benchmarks, rhs: Benchmarks) -> Bool {
    if lhs.benchmarks != rhs.benchmarks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GradingCriterion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GradingCriterion"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
    2: .same(proto: "points"),
    3: .same(proto: "benchmarkID"),
    4: .same(proto: "description"),
    5: .same(proto: "grade"),
    6: .same(proto: "comment"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.points) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.benchmarkID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.grade) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.comment) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.points != 0 {
      try visitor.visitSingularUInt64Field(value: self.points, fieldNumber: 2)
    }
    if self.benchmarkID != 0 {
      try visitor.visitSingularUInt64Field(value: self.benchmarkID, fieldNumber: 3)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 4)
    }
    if self.grade != .none {
      try visitor.visitSingularEnumField(value: self.grade, fieldNumber: 5)
    }
    if !self.comment.isEmpty {
      try visitor.visitSingularStringField(value: self.comment, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GradingCriterion, rhs: GradingCriterion) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.points != rhs.points {return false}
    if lhs.benchmarkID != rhs.benchmarkID {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.grade != rhs.grade {return false}
    if lhs.comment != rhs.comment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GradingCriterion.Grade: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "FAILED"),
    2: .same(proto: "PASSED"),
  ]
}

extension Review: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Review"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
    2: .same(proto: "submissionID"),
    3: .same(proto: "reviewerID"),
    4: .same(proto: "review"),
    5: .same(proto: "feedback"),
    6: .same(proto: "ready"),
    7: .same(proto: "score"),
    8: .same(proto: "benchmarks"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.submissionID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.reviewerID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.review) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.feedback) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.ready) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.score) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.benchmarks) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.submissionID != 0 {
      try visitor.visitSingularUInt64Field(value: self.submissionID, fieldNumber: 2)
    }
    if self.reviewerID != 0 {
      try visitor.visitSingularUInt64Field(value: self.reviewerID, fieldNumber: 3)
    }
    if !self.review.isEmpty {
      try visitor.visitSingularStringField(value: self.review, fieldNumber: 4)
    }
    if !self.feedback.isEmpty {
      try visitor.visitSingularStringField(value: self.feedback, fieldNumber: 5)
    }
    if self.ready != false {
      try visitor.visitSingularBoolField(value: self.ready, fieldNumber: 6)
    }
    if self.score != 0 {
      try visitor.visitSingularUInt64Field(value: self.score, fieldNumber: 7)
    }
    if !self.benchmarks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.benchmarks, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Review, rhs: Review) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.submissionID != rhs.submissionID {return false}
    if lhs.reviewerID != rhs.reviewerID {return false}
    if lhs.review != rhs.review {return false}
    if lhs.feedback != rhs.feedback {return false}
    if lhs.ready != rhs.ready {return false}
    if lhs.score != rhs.score {return false}
    if lhs.benchmarks != rhs.benchmarks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Reviewers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Reviewers"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reviewers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.reviewers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reviewers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reviewers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Reviewers, rhs: Reviewers) -> Bool {
    if lhs.reviewers != rhs.reviewers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ReviewRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ReviewRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "courseID"),
    2: .same(proto: "review"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.courseID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._review) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.courseID != 0 {
      try visitor.visitSingularUInt64Field(value: self.courseID, fieldNumber: 1)
    }
    if let v = self._review {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ReviewRequest, rhs: ReviewRequest) -> Bool {
    if lhs.courseID != rhs.courseID {return false}
    if lhs._review != rhs._review {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CourseRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CourseRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "courseID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.courseID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.courseID != 0 {
      try visitor.visitSingularUInt64Field(value: self.courseID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CourseRequest, rhs: CourseRequest) -> Bool {
    if lhs.courseID != rhs.courseID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UserRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularUInt64Field(value: self.userID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UserRequest, rhs: UserRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetGroupRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groupID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.groupID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularUInt64Field(value: self.groupID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GetGroupRequest, rhs: GetGroupRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GroupRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userID"),
    2: .same(proto: "groupID"),
    3: .same(proto: "courseID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.groupID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.courseID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularUInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.groupID != 0 {
      try visitor.visitSingularUInt64Field(value: self.groupID, fieldNumber: 2)
    }
    if self.courseID != 0 {
      try visitor.visitSingularUInt64Field(value: self.courseID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GroupRequest, rhs: GroupRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.courseID != rhs.courseID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Provider: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Provider"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "provider"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.provider) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.provider.isEmpty {
      try visitor.visitSingularStringField(value: self.provider, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Provider, rhs: Provider) -> Bool {
    if lhs.provider != rhs.provider {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OrgRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "OrgRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "orgName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.orgName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.orgName.isEmpty {
      try visitor.visitSingularStringField(value: self.orgName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: OrgRequest, rhs: OrgRequest) -> Bool {
    if lhs.orgName != rhs.orgName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Organization: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Organization"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ID"),
    2: .same(proto: "path"),
    3: .same(proto: "avatar"),
    4: .same(proto: "paymentPlan"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.avatar) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.paymentPlan) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 2)
    }
    if !self.avatar.isEmpty {
      try visitor.visitSingularStringField(value: self.avatar, fieldNumber: 3)
    }
    if !self.paymentPlan.isEmpty {
      try visitor.visitSingularStringField(value: self.paymentPlan, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Organization, rhs: Organization) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.path != rhs.path {return false}
    if lhs.avatar != rhs.avatar {return false}
    if lhs.paymentPlan != rhs.paymentPlan {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Organizations: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Organizations"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "organizations"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.organizations) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.organizations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.organizations, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Organizations, rhs: Organizations) -> Bool {
    if lhs.organizations != rhs.organizations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EnrollmentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "EnrollmentRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "courseID"),
    2: .same(proto: "ignoreGroupMembers"),
    3: .same(proto: "withActivity"),
    4: .same(proto: "statuses"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.courseID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.ignoreGroupMembers) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.withActivity) }()
      case 4: try { try decoder.decodeRepeatedEnumField(value: &self.statuses) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.courseID != 0 {
      try visitor.visitSingularUInt64Field(value: self.courseID, fieldNumber: 1)
    }
    if self.ignoreGroupMembers != false {
      try visitor.visitSingularBoolField(value: self.ignoreGroupMembers, fieldNumber: 2)
    }
    if self.withActivity != false {
      try visitor.visitSingularBoolField(value: self.withActivity, fieldNumber: 3)
    }
    if !self.statuses.isEmpty {
      try visitor.visitPackedEnumField(value: self.statuses, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: EnrollmentRequest, rhs: EnrollmentRequest) -> Bool {
    if lhs.courseID != rhs.courseID {return false}
    if lhs.ignoreGroupMembers != rhs.ignoreGroupMembers {return false}
    if lhs.withActivity != rhs.withActivity {return false}
    if lhs.statuses != rhs.statuses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EnrollmentStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "EnrollmentStatusRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userID"),
    2: .same(proto: "statuses"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.statuses) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularUInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.statuses.isEmpty {
      try visitor.visitPackedEnumField(value: self.statuses, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: EnrollmentStatusRequest, rhs: EnrollmentStatusRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.statuses != rhs.statuses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubmissionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SubmissionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userID"),
    2: .same(proto: "groupID"),
    3: .same(proto: "courseID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.groupID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.courseID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularUInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.groupID != 0 {
      try visitor.visitSingularUInt64Field(value: self.groupID, fieldNumber: 2)
    }
    if self.courseID != 0 {
      try visitor.visitSingularUInt64Field(value: self.courseID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SubmissionRequest, rhs: SubmissionRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.courseID != rhs.courseID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateSubmissionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UpdateSubmissionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "submissionID"),
    2: .same(proto: "courseID"),
    3: .same(proto: "score"),
    4: .same(proto: "released"),
    5: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.submissionID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.courseID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.score) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.released) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.submissionID != 0 {
      try visitor.visitSingularUInt64Field(value: self.submissionID, fieldNumber: 1)
    }
    if self.courseID != 0 {
      try visitor.visitSingularUInt64Field(value: self.courseID, fieldNumber: 2)
    }
    if self.score != 0 {
      try visitor.visitSingularUInt32Field(value: self.score, fieldNumber: 3)
    }
    if self.released != false {
      try visitor.visitSingularBoolField(value: self.released, fieldNumber: 4)
    }
    if self.status != .none {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UpdateSubmissionRequest, rhs: UpdateSubmissionRequest) -> Bool {
    if lhs.submissionID != rhs.submissionID {return false}
    if lhs.courseID != rhs.courseID {return false}
    if lhs.score != rhs.score {return false}
    if lhs.released != rhs.released {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateSubmissionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UpdateSubmissionsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "courseID"),
    2: .same(proto: "assignmentID"),
    3: .same(proto: "scoreLimit"),
    4: .same(proto: "release"),
    5: .same(proto: "approve"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.courseID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.assignmentID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.scoreLimit) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.release) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.approve) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.courseID != 0 {
      try visitor.visitSingularUInt64Field(value: self.courseID, fieldNumber: 1)
    }
    if self.assignmentID != 0 {
      try visitor.visitSingularUInt64Field(value: self.assignmentID, fieldNumber: 2)
    }
    if self.scoreLimit != 0 {
      try visitor.visitSingularUInt32Field(value: self.scoreLimit, fieldNumber: 3)
    }
    if self.release != false {
      try visitor.visitSingularBoolField(value: self.release, fieldNumber: 4)
    }
    if self.approve != false {
      try visitor.visitSingularBoolField(value: self.approve, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UpdateSubmissionsRequest, rhs: UpdateSubmissionsRequest) -> Bool {
    if lhs.courseID != rhs.courseID {return false}
    if lhs.assignmentID != rhs.assignmentID {return false}
    if lhs.scoreLimit != rhs.scoreLimit {return false}
    if lhs.release != rhs.release {return false}
    if lhs.approve != rhs.approve {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubmissionReviewersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SubmissionReviewersRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "submissionID"),
    2: .same(proto: "courseID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.submissionID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.courseID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.submissionID != 0 {
      try visitor.visitSingularUInt64Field(value: self.submissionID, fieldNumber: 1)
    }
    if self.courseID != 0 {
      try visitor.visitSingularUInt64Field(value: self.courseID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SubmissionReviewersRequest, rhs: SubmissionReviewersRequest) -> Bool {
    if lhs.submissionID != rhs.submissionID {return false}
    if lhs.courseID != rhs.courseID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Providers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Providers"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "providers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.providers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.providers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.providers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Providers, rhs: Providers) -> Bool {
    if lhs.providers != rhs.providers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension URLRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "URLRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "courseID"),
    2: .same(proto: "repoTypes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.courseID) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.repoTypes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.courseID != 0 {
      try visitor.visitSingularUInt64Field(value: self.courseID, fieldNumber: 1)
    }
    if !self.repoTypes.isEmpty {
      try visitor.visitPackedEnumField(value: self.repoTypes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: URLRequest, rhs: URLRequest) -> Bool {
    if lhs.courseID != rhs.courseID {return false}
    if lhs.repoTypes != rhs.repoTypes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RepositoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RepositoryRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userID"),
    2: .same(proto: "groupID"),
    3: .same(proto: "courseID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.groupID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.courseID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularUInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.groupID != 0 {
      try visitor.visitSingularUInt64Field(value: self.groupID, fieldNumber: 2)
    }
    if self.courseID != 0 {
      try visitor.visitSingularUInt64Field(value: self.courseID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RepositoryRequest, rhs: RepositoryRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.courseID != rhs.courseID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Repositories: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Repositories"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "URLs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.urls) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.urls.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.urls, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Repositories, rhs: Repositories) -> Bool {
    if lhs.urls != rhs.urls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AuthorizationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AuthorizationResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "IsAuthorized"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isAuthorized) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isAuthorized != false {
      try visitor.visitSingularBoolField(value: self.isAuthorized, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AuthorizationResponse, rhs: AuthorizationResponse) -> Bool {
    if lhs.isAuthorized != rhs.isAuthorized {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Status: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Status"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Code"),
    2: .same(proto: "Error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularUInt64Field(value: self.code, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Status, rhs: Status) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubmissionsForCourseRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SubmissionsForCourseRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "courseID"),
    2: .same(proto: "type"),
    3: .same(proto: "skipBuildInfo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.courseID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.skipBuildInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.courseID != 0 {
      try visitor.visitSingularUInt64Field(value: self.courseID, fieldNumber: 1)
    }
    if self.type != .all {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if self.skipBuildInfo != false {
      try visitor.visitSingularBoolField(value: self.skipBuildInfo, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SubmissionsForCourseRequest, rhs: SubmissionsForCourseRequest) -> Bool {
    if lhs.courseID != rhs.courseID {return false}
    if lhs.type != rhs.type {return false}
    if lhs.skipBuildInfo != rhs.skipBuildInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubmissionsForCourseRequest.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALL"),
    1: .same(proto: "INDIVIDUAL"),
    2: .same(proto: "GROUP"),
  ]
}

extension RebuildRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RebuildRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "submissionID"),
    2: .same(proto: "assignmentID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.submissionID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.assignmentID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.submissionID != 0 {
      try visitor.visitSingularUInt64Field(value: self.submissionID, fieldNumber: 1)
    }
    if self.assignmentID != 0 {
      try visitor.visitSingularUInt64Field(value: self.assignmentID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RebuildRequest, rhs: RebuildRequest) -> Bool {
    if lhs.submissionID != rhs.submissionID {return false}
    if lhs.assignmentID != rhs.assignmentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CourseUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CourseUserRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "courseCode"),
    2: .same(proto: "courseYear"),
    3: .same(proto: "userLogin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.courseCode) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.courseYear) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.userLogin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.courseCode.isEmpty {
      try visitor.visitSingularStringField(value: self.courseCode, fieldNumber: 1)
    }
    if self.courseYear != 0 {
      try visitor.visitSingularUInt32Field(value: self.courseYear, fieldNumber: 2)
    }
    if !self.userLogin.isEmpty {
      try visitor.visitSingularStringField(value: self.userLogin, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CourseUserRequest, rhs: CourseUserRequest) -> Bool {
    if lhs.courseCode != rhs.courseCode {return false}
    if lhs.courseYear != rhs.courseYear {return false}
    if lhs.userLogin != rhs.userLogin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LoadCriteriaRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LoadCriteriaRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "courseID"),
    2: .same(proto: "assignmentID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.courseID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.assignmentID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.courseID != 0 {
      try visitor.visitSingularUInt64Field(value: self.courseID, fieldNumber: 1)
    }
    if self.assignmentID != 0 {
      try visitor.visitSingularUInt64Field(value: self.assignmentID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LoadCriteriaRequest, rhs: LoadCriteriaRequest) -> Bool {
    if lhs.courseID != rhs.courseID {return false}
    if lhs.assignmentID != rhs.assignmentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Void: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Void"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Void, rhs: Void) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
